// +build ignore

package main

import (
	"bytes"
	"encoding/csv"
	"fmt"
	"log"
	"os"
	"strconv"
)

func main() {
	f, err := os.Open("name.csv")
	check(err)
	defer f.Close()

	recs, err := csv.NewReader(f).ReadAll()
	check(err)

	var cat string
	namemap := make(map[string]struct{})
	var names []nameRec
	maxNameWidth := 0
	for _, r := range recs {
		if r[1] == "" {
			cat = r[0]
		} else {
			dec, err := strconv.ParseInt(r[2], 10, 0)
			if err != nil {
				log.Fatalf("invalid dec %q for %s", r[2], r[1])
			}
			hex, err := strconv.ParseInt(r[3], 16, 0)
			if err != nil {
				log.Fatalf("invalid hex %q for %s", r[3], r[1])
			}
			if dec != hex {
				log.Fatalf("invalid hex/dex mismatch %q for %s", r[2], r[3], r[1])
			}
			n := nameRec{
				cat, r[0], r[1], int(dec), r[4], r[5],
			}
			names = append(names, n)
			if _, ok := namemap[n.Id]; ok {
				log.Fatalf("duplicate id %q", n.Id)
				namemap[n.Id] = struct{}{}
			}
			if len(n.Id) > maxNameWidth {
				maxNameWidth = len(n.Id)
			}
		}
	}

	cbuf := new(bytes.Buffer)
	xbuf := new(bytes.Buffer)

	cbuf.WriteString("const (")
	xbuf.WriteString("var nameMap = map[uint32]name{\n")

	for _, n := range names {
		fmt.Fprintln(cbuf)
		fmt.Fprintf(cbuf, "\t// %s - %s (%s)\n", n.Desc, n.Type, n.Len)
		fmt.Fprintf(cbuf, "\t%s = %s | %#04x\n", n.Id, n.Cat, n.Name)

		fmt.Fprintf(xbuf, "\t%-*s {%q, %q},\n", maxNameWidth+1, n.Id+":", n.Id, n.Desc)
	}

	cbuf.WriteString(")\n")
	xbuf.WriteString("}\n")

	f, err = os.Create("name.go")
	check(err)
	defer f.Close()

	_, err = fmt.Fprint(f, `// generated by gen_name.go -- DO NOT EDIT

package exiftag`+"\n\n")
	check(err)

	_, err = cbuf.WriteTo(f)
	check(err)

	_, err = fmt.Fprintln(f)
	check(err)

	_, err = xbuf.WriteTo(f)
	check(err)
}

type nameRec struct {
	Cat  string
	Desc string
	Id   string
	Name int
	Type string
	Len  string
}

func check(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
